## 思想
采用分治思想。把一整个数组先一分为二，然后继续两半分，分到以每个元素为一个个体，然后执行merge。\\merge的时候要开辟一个临时数组，两个区间各自从最左边的数比较，较小的元素写到临时数组的当前下标位置，然后下标++，那个较小数的位置也要++。最后还要把这个临时数组写回到原始数组中,其实也只写回right - left这部分。

## code
```java
import java.util.Arrays;

public class MergeSort {
    public static void main(String[] args) {
        int[] arr = new int[]{9,8,7,6,5};
        sort( arr,0,arr.length-1 );
        System.out.println( Arrays.toString(arr));   //输出为[5,6,7,8,9]

    }
    public static void sort(int[] arr, int left, int right){
        if(left < right){
            int mid = (left + right) / 2;
            sort( arr,left,mid );  //递归
            sort( arr,mid + 1,right); 
            merge( arr,left,mid,right);
        }
    }

    public static void merge(int[] data, int left, int center, int right) {
        // 临时数组
        int[] tmpArr = new int[data.length];
        // 右数组第一个元素索引
        int mid = center + 1;
        
        // tmp 记录临时数组的索引
        int tmp = left;

        // 缓存左数组第一个元素的索引 最后要写回原数组
        int i = left;

        while (left <= center && mid <= right) {
            // 从两个数组中取出最小的放入临时数组
            if (data[left] <= data[mid]) {
                tmpArr[tmp++] = data[left++];
            } else {
                tmpArr[tmp++] = data[mid++];
            }
        }
        // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个）
        while (mid <= right) {
            tmpArr[tmp++] = data[mid++];
        }
        while (left <= center) {
            tmpArr[tmp++] = data[left++];
        }
        // 将临时数组中的内容拷贝回原数组中
        // （原left-right范围的内容被复制回原数组）
        while (i <= right) {
            data[i] = tmpArr[i++];
        }
    }
}

```
归并排序时间复杂度是nlogn  但是需要额外的空间O(n)。
是稳定的排序。因为如果顺序是2  2*  merge的时候也是按顺序从左到右先比较的2然后是2*。