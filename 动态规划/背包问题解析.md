# 01背包
有一个容量为V的背包，有n个物品，每个物品体积为C[i],价值为W[i]。求最后背包中所装物品能得到的最大价值。
## 思路
对于每个物品都有装还是不装两种选择，如果装了则剩余背包容量会减小，背包价值增大。由此分析得出状态转移方程,dp[i][j]含义为前i个物品背包容量为j时能获得的最大价值。状态转移方程为：dp[i][j] = max(dp[i-1][j],dp[i-1][j-C[i]+W[i]]) 意思是不选当前物品时容量为j 选了当前物品容量为j-C[i]但是价值要加上W[i]。<br/>

## 01背包变形题
leetcode416:分割等和子集。就是给定一个只包含正整数的非空数组，能否将该数组分成两个子集且子集内元素和相等。<br/>
如果用暴力法遍历会超时，此题其实考察的背包问题。背包最大容量为数组和的一半（设为target），就是问能否在数组中找到一些元素，他们的和为target。则dp[i][j]肯定是一个bool型数组，dp[i][j]含义为前i个数能否恰好构成和为j的子集。有选nums[i-1]和不选两种，如果选，则dp[i-1][j-nums[i-1]]，如果不选，则dp[i-1][j]。
```Python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums)%2!=0:
            return False
        target = sum(nums)//2
        n = len(nums)
        if n == 1:
            return False
        dp = [[False]*(target+1) for _ in range(n+1)]
        for i in range(n+1):
            dp[i][0] = True   #注意边界
        for i in range(1,n+1):
            for j in range(1,target+1):
                if nums[i-1] == j:  #这句可省略，但是我是想的是如果当前这个数已经等于目标了，就直接为True
                    dp[i][j] = True
                else:
                    dp[i][j] = dp[i-1][j-nums[i-1]] or dp[i-1][j]  #其实应该讨论j是否大于nums[i-1]情况，但这样写也过了
        return dp[n][target]

```
上述方法时间复杂度为O(n * target)，由于dp[i][*]只和dp[i-1][*]有关，所以考虑压缩成一维。
```Python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums)%2!=0:
            return False
        target = sum(nums)//2
        n = len(nums)
        if n == 1:
            return False
        dp = [False]*(target+1)
        dp[0] = True
        for i in range(n):
            for j in range(target,0,-1):  #j要倒序遍历，因为每个数字只能用一次，避免前面的结果影响后面
                if j >= nums[i]:
                    dp[j] = dp[j] or dp[j-nums[i]]
        return dp[target]
```
对于输入[1,2,3],如果输出dp过程，为dp[3]=False,dp[2]=False,dp[1]=False,dp[3]=True,dp[2]=True,dp[1]=True,dp[3]=True,dp[2]=True,dp[1]=True。所以最后的target dp[3]=True。